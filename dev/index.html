<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SpectralInference.jl</title><meta name="title" content="Home · SpectralInference.jl"/><meta property="og:title" content="Home · SpectralInference.jl"/><meta property="twitter:title" content="Home · SpectralInference.jl"/><meta name="description" content="Documentation for SpectralInference.jl."/><meta property="og:description" content="Documentation for SpectralInference.jl."/><meta property="twitter:description" content="Documentation for SpectralInference.jl."/><meta property="og:url" content="https://aramanlab.github.io/SpectralInference.jl/"/><meta property="twitter:url" content="https://aramanlab.github.io/SpectralInference.jl/"/><link rel="canonical" href="https://aramanlab.github.io/SpectralInference.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SpectralInference.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aramanlab/SpectralInference.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SpectralInference"><a class="docs-heading-anchor" href="#SpectralInference">SpectralInference</a><a id="SpectralInference-1"></a><a class="docs-heading-anchor-permalink" href="#SpectralInference" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/aramanlab/SpectralInference.jl">SpectralInference</a>.</p><ul><li><a href="#SpectralInference.UPGMA_tree-Tuple{AbstractMatrix{&lt;:Number}}"><code>SpectralInference.UPGMA_tree</code></a></li><li><a href="#SpectralInference.adjustedrandindex-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>SpectralInference.adjustedrandindex</code></a></li><li><a href="#SpectralInference.as_polytomy"><code>SpectralInference.as_polytomy</code></a></li><li><a href="#SpectralInference.as_polytomy!"><code>SpectralInference.as_polytomy!</code></a></li><li><a href="#SpectralInference.clusters_per_cutlevel"><code>SpectralInference.clusters_per_cutlevel</code></a></li><li><a href="#SpectralInference.collectiveLCA"><code>SpectralInference.collectiveLCA</code></a></li><li><a href="#SpectralInference.cuttree"><code>SpectralInference.cuttree</code></a></li><li><a href="#SpectralInference.distancematrix_spaceneeded-Tuple{Any}"><code>SpectralInference.distancematrix_spaceneeded</code></a></li><li><a href="#SpectralInference.distancetrace_spaceneeded-Tuple{Any, Any}"><code>SpectralInference.distancetrace_spaceneeded</code></a></li><li><a href="#SpectralInference.empiricalMI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>SpectralInference.empiricalMI</code></a></li><li><a href="#SpectralInference.explainedvariance-Tuple{AbstractVector{&lt;:Number}}"><code>SpectralInference.explainedvariance</code></a></li><li><a href="#SpectralInference.fscore_precision_recall"><code>SpectralInference.fscore_precision_recall</code></a></li><li><a href="#SpectralInference.getintervals-Tuple{AbstractVector{&lt;:Number}}"><code>SpectralInference.getintervals</code></a></li><li><a href="#SpectralInference.getintervalsIQR-Tuple{AbstractVector{&lt;:Number}}"><code>SpectralInference.getintervalsIQR</code></a></li><li><a href="#SpectralInference.getleafids"><code>SpectralInference.getleafids</code></a></li><li><a href="#SpectralInference.getleafnames"><code>SpectralInference.getleafnames</code></a></li><li><a href="#SpectralInference.ij2k-Tuple{Any, Any, Any}"><code>SpectralInference.ij2k</code></a></li><li><a href="#SpectralInference.k2ij-Tuple{Any, Any}"><code>SpectralInference.k2ij</code></a></li><li><a href="#SpectralInference.ladderize!"><code>SpectralInference.ladderize!</code></a></li><li><a href="#SpectralInference.mapinternalnodes"><code>SpectralInference.mapinternalnodes</code></a></li><li><a href="#SpectralInference.maplocalnodes"><code>SpectralInference.maplocalnodes</code></a></li><li><a href="#SpectralInference.mapnodes"><code>SpectralInference.mapnodes</code></a></li><li><a href="#SpectralInference.network_distance"><code>SpectralInference.network_distance</code></a></li><li><a href="#SpectralInference.network_distances"><code>SpectralInference.network_distances</code></a></li><li><a href="#SpectralInference.newickstring-Tuple{Clustering.Hclust}"><code>SpectralInference.newickstring</code></a></li><li><a href="#SpectralInference.pairedMI_across_treedepth"><code>SpectralInference.pairedMI_across_treedepth</code></a></li><li><a href="#SpectralInference.pairwise-Tuple{Function, AbstractMatrix}"><code>SpectralInference.pairwise</code></a></li><li><a href="#SpectralInference.patristic_distance"><code>SpectralInference.patristic_distance</code></a></li><li><a href="#SpectralInference.patristic_distances"><code>SpectralInference.patristic_distances</code></a></li><li><a href="#SpectralInference.projectinLSV-Tuple{AbstractArray, SVD}"><code>SpectralInference.projectinLSV</code></a></li><li><a href="#SpectralInference.projectinRSV-Tuple{AbstractArray, SVD}"><code>SpectralInference.projectinRSV</code></a></li><li><a href="#SpectralInference.projectout-Tuple{SVD}"><code>SpectralInference.projectout</code></a></li><li><a href="#SpectralInference.readphylip-Tuple{AbstractString}"><code>SpectralInference.readphylip</code></a></li><li><a href="#SpectralInference.scaledcumsum-Tuple{Any}"><code>SpectralInference.scaledcumsum</code></a></li><li><a href="#SpectralInference.spectral_lineage_encoding"><code>SpectralInference.spectral_lineage_encoding</code></a></li><li><a href="#SpectralInference.spectralcorrelations-Tuple{AbstractMatrix{&lt;:Number}, Any}"><code>SpectralInference.spectralcorrelations</code></a></li><li><a href="#SpectralInference.spectraldistances-Tuple{AbstractMatrix{&lt;:Number}}"><code>SpectralInference.spectraldistances</code></a></li><li><a href="#SpectralInference.spectraldistances_trace-Tuple{SVD}"><code>SpectralInference.spectraldistances_trace</code></a></li><li><a href="#SpectralInference.squareform"><code>SpectralInference.squareform</code></a></li><li><a href="#SpectralInference.vmeasure_homogeneity_completeness-Tuple{Any, Any}"><code>SpectralInference.vmeasure_homogeneity_completeness</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.UPGMA_tree-Tuple{AbstractMatrix{&lt;:Number}}" href="#SpectralInference.UPGMA_tree-Tuple{AbstractMatrix{&lt;:Number}}"><code>SpectralInference.UPGMA_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UPGMA_tree(Dij::AbstractMatrix{&lt;:Number})</code></pre><p>shorthand for <code>Clustering.hclust(Dij, linkage=:average, branchorder=:optimal)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.adjustedrandindex-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#SpectralInference.adjustedrandindex-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>SpectralInference.adjustedrandindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjustedrandindex(a::AbstractVector{&lt;:Number}, b::AbstractVector{&lt;:Number}; nbins=50)</code></pre><p>Args:</p><ul><li>a, vector of numbers</li><li>b, vector of numbers</li><li>nbins, for continuous approximates discrete, for discrete choose nbins&gt;max<em>number</em>of_classes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/empiricalMI.jl#L178-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.as_polytomy" href="#SpectralInference.as_polytomy"><code>SpectralInference.as_polytomy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">as_polytomy(f::Function, tree)</code></pre><p>Makes a copy of the tree, then removes nodes. function <code>f</code> should return <code>true</code> if the node is to be removed. Children of node are attached to the parent of the removed node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.as_polytomy!" href="#SpectralInference.as_polytomy!"><code>SpectralInference.as_polytomy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">as_polytomy!(f::Function, tree)</code></pre><p>in-place removal of nodes. function <code>f</code> should return <code>true</code> if the node is to be removed. Children of node are attached to the parent of the removed node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.clusters_per_cutlevel" href="#SpectralInference.clusters_per_cutlevel"><code>SpectralInference.clusters_per_cutlevel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clusters_per_cutlevel(distfun::Function, tree::Node, ncuts::Number)</code></pre><p>Returns:</p><ul><li>clusts: vector of cluster-memberships. each value indicates the cluster membership of the leaf at that cut.    leaves are ordered in prewalk order within each membership vector</li><li>treedepths: distance from root for each of the <code>ncuts</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.collectiveLCA" href="#SpectralInference.collectiveLCA"><code>SpectralInference.collectiveLCA</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collectiveLCA(treenodes::AbstractVector)</code></pre><p>returns last common ancestor of the vector of treenodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L52-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.cuttree" href="#SpectralInference.cuttree"><code>SpectralInference.cuttree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cuttree(tree, θ)</code></pre><p>return vector of nodes whose distance from the root are &lt; θ and whose children&#39;s distance to the root are &gt; θ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.distancematrix_spaceneeded-Tuple{Any}" href="#SpectralInference.distancematrix_spaceneeded-Tuple{Any}"><code>SpectralInference.distancematrix_spaceneeded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distancematrix_spaceneeded(n, p; bits=64) = Base.format_bytes(binomial(n,2) * p * bits)</code></pre><p>how much memory is needed to store distance matrix Args:</p><ul><li>n: number of samples</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/helpers.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.distancetrace_spaceneeded-Tuple{Any, Any}" href="#SpectralInference.distancetrace_spaceneeded-Tuple{Any, Any}"><code>SpectralInference.distancetrace_spaceneeded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distancetrace_spaceneeded(n, p; bits=64) = Base.format_bytes(binomial(n,2) * p * bits)</code></pre><p>how much memory is needed to store spectral residual trace</p><p>Args:</p><ul><li>n: number of samples</li><li>p: number of partitions/components</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/helpers.jl#L19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.empiricalMI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#SpectralInference.empiricalMI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>SpectralInference.empiricalMI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empiricalMI(a::AbstractVector{&lt;:Float}, b::AbstractVector{&lt;:Float}[; nbins=50, edges_a=nothing, edges_b=nothing, normalize=false])
empiricalMI(ab::AbstractVector{F}, mask::AbstractVector{&lt;:Bool}[; nbins=100, edges=nothing, base=ℯ, normalize=false])</code></pre><p>computes empirical MI from identity of <span>$H(a) + H(b) - H(a,b)$</span>. where <span>$H := -sum(p(x)*log(p(x))) + log(Δ)$</span> the <span>$+ log(Δ)$</span> corresponds to the log binwidth and unbiases the entropy estimate from binwidth choice. estimates are roughly stable from <span>$32$</span> (<span>$32^2 ≈ 1000$</span> total bins) to size of sample. going from a small undersestimate to a small overestimate across that range. We recommend choosing the <code>sqrt(mean(1000, samplesize))</code> for <code>nbins</code> argument, or taking a few estimates across that range and averaging.</p><p>Args:</p><ul><li>a, vecter of length N</li><li>b, AbstractVector of length N</li><li>nbins, number of bins per side, use 1000 &lt; nbins^2 &lt; length(a) for best results</li><li>edges_a, defaults to <code>nothing</code>. If provided is used as the breaks defining bins for <code>a</code>, <code>nbins</code> will be ignored</li><li>edges_b, defaults to <code>nothing</code>. If provided is used as the breaks defining bins for <code>b</code>, <code>nbins</code> will be ignored</li><li>base, base unit of MI (defaults to nats with base=ℯ)</li><li>normalize, bool, whether to normalize with mi / mean(ha, hb)</li></ul><p>Returns:</p><ul><li>MI</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/empiricalMI.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.explainedvariance-Tuple{AbstractVector{&lt;:Number}}" href="#SpectralInference.explainedvariance-Tuple{AbstractVector{&lt;:Number}}"><code>SpectralInference.explainedvariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">explainedvariance(s::AbstractVector{&lt;:Number})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/helpers.jl#L12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.fscore_precision_recall" href="#SpectralInference.fscore_precision_recall"><code>SpectralInference.fscore_precision_recall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fscore_precision_recall(reftree, predictedtree)</code></pre><p>fscore, precision, and recall of branches between the two trees</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.getintervals-Tuple{AbstractVector{&lt;:Number}}" href="#SpectralInference.getintervals-Tuple{AbstractVector{&lt;:Number}}"><code>SpectralInference.getintervals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getintervals(S::AbstractVector{&lt;:Number}; alpha=1.0, q=0.5)</code></pre><p>finds spectral partitions. Computes log difference between each subsequent singular value and by default selects the differences that are larger than <code>1.0 * Q2(differences)</code></p><p>i.e. finds breaks in the spectrum that explain smaller scales of variance</p><p>Args:</p><ul><li>S: singular values of a SVD factorization</li><li>alpha: scalar multiple of <code>q</code></li><li>q: which quantile of log differences to use; by default Q2 </li></ul><p>Returns:</p><ul><li>AbstractVector{UnitRange} indices into S corresponding to the spectral partitions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.getintervalsIQR-Tuple{AbstractVector{&lt;:Number}}" href="#SpectralInference.getintervalsIQR-Tuple{AbstractVector{&lt;:Number}}"><code>SpectralInference.getintervalsIQR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getintervals_IQR(S::AbstractVector{&lt;:Number}; alpha=1.5, ql=.25, qh=.75)</code></pre><p>finds spectral partitions. Computes log difference between each subsequent singular value and by default selects the differences that are larger than <code>1.5 * IQR(differences)</code></p><p>i.e. finds breaks in the spectrum that explain smaller scales of variance</p><p>Args:</p><ul><li>S: singular values of a SVD factorization</li><li>alpha: scalar multiple of <code>q</code></li><li>q: which quantile of log differences to use; by default Q3 </li></ul><p>Returns:</p><ul><li>AbstractVector{UnitRange} indices into S corresponding to the spectral partitions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.getleafids" href="#SpectralInference.getleafids"><code>SpectralInference.getleafids</code></a> — <span class="docstring-category">Function</span></header><section><div><p>returns ids of all leaves desended from a node in prewalk order </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.getleafnames" href="#SpectralInference.getleafnames"><code>SpectralInference.getleafnames</code></a> — <span class="docstring-category">Function</span></header><section><div><p>returns names of all leaves desended from a node in prewalk order </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.ij2k-Tuple{Any, Any, Any}" href="#SpectralInference.ij2k-Tuple{Any, Any, Any}"><code>SpectralInference.ij2k</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ij2k(i,j,n)</code></pre><p>with pair <code>(i,j)</code> give index <code>k</code> to the pairs produced by combinations(vec), where vec is length <code>n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/helpers.jl#L100-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.k2ij-Tuple{Any, Any}" href="#SpectralInference.k2ij-Tuple{Any, Any}"><code>SpectralInference.k2ij</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k2ij(k, n)</code></pre><p>which pair <code>(i,j)</code> produces the <code>k</code>th element of combinations(vec), where vec is length <code>n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/helpers.jl#L89-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.ladderize!" href="#SpectralInference.ladderize!"><code>SpectralInference.ladderize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ladderize!(tree, rev=false)</code></pre><p>sorts children of each node by number of leaves descending from the child in ascending order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L97-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.mapinternalnodes" href="#SpectralInference.mapinternalnodes"><code>SpectralInference.mapinternalnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapinternalnodes(f::Function, tree)</code></pre><p>maps across all nodes that have children in prewalk order and applies function <code>f(node)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L42-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.maplocalnodes" href="#SpectralInference.maplocalnodes"><code>SpectralInference.maplocalnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maplocalnodes(f::Function, tree)</code></pre><p>maps across all nodes that have a leaf as a child in prewalk order and applies function <code>f(node)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.mapnodes" href="#SpectralInference.mapnodes"><code>SpectralInference.mapnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapnodes(f::Function, tree)</code></pre><p>maps across all nodes that have children in prewalk order and applies function <code>f(node)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L37-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.network_distance" href="#SpectralInference.network_distance"><code>SpectralInference.network_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">network_distance(leaf_i, leaf_j)</code></pre><p>returns network distance between two leaves </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.network_distances" href="#SpectralInference.network_distances"><code>SpectralInference.network_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">network_distances(tree::Node)</code></pre><p>returns network distances between all pairs of leaves (leaves are in same order as <code>getleafnames</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.newickstring-Tuple{Clustering.Hclust}" href="#SpectralInference.newickstring-Tuple{Clustering.Hclust}"><code>SpectralInference.newickstring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newickstring(hc::Hclust[, tiplabels::AbstractVector[&lt;:String]])</code></pre><p>convert Hclust to newick tree string</p><p>Args:</p><ul><li>hc: <code>Hclust</code> object from Clustering package</li><li>tiplabels: <code>AbstractVector{&lt;:String}</code> names in same order as distance matrix</li></ul><p>Returns:</p><ul><li><a href="https://en.wikipedia.org/wiki/Newick_format">newick tree</a> formated string</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L206-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.pairedMI_across_treedepth" href="#SpectralInference.pairedMI_across_treedepth"><code>SpectralInference.pairedMI_across_treedepth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pairedMI_across_treedepth(metacolumns, metacolumns_ids, tree)
pairedMI_across_treedepth(metacolumns, metacolumns_ids, compare::Function=(==), tree::Node; ncuts=100, bootstrap=false, mask=nothing)</code></pre><p>iterates over each metacolumn and calculates MI between the paired elements of the metacolumn and the paired elements of tree clusters.</p><p>Args:</p><ul><li>metacolumns: column iterator, can be fed to <code>map(metacolumns)</code></li><li>metacolumn_ids: ids for each element in the metacolumn. should match the leafnames of the tree, but not necessarily the order.</li><li>tree: NewickTree tree</li><li>compare: function used to calculate similarity of two elements in metacolumn. Should be written for each element as it will be broadcast across all pairs.</li></ul><p>Returns:</p><ul><li>(; MI, treedepths)</li><li>MI: Vector{Vector{Float64}} MI for each metacolumn and each tree depth</li><li>treedepths Vector{&lt;:Number} tree depth (away from root) for each cut of the tree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L69-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.pairwise-Tuple{Function, AbstractMatrix}" href="#SpectralInference.pairwise-Tuple{Function, AbstractMatrix}"><code>SpectralInference.pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pairwise(func::Function, m::AbstractMatrix)</code></pre><p>returns the lower columnwise offdiagonal of <code>result[k] = func(i, j)</code>  where k is the kth pair and i and j are the ith and kth columns of m  calculated from <code>enumerate(((i, j) for j in axes(m, 2) for i in (j+1):lastindex(m, 2)))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/helpers.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.patristic_distance" href="#SpectralInference.patristic_distance"><code>SpectralInference.patristic_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">patristic_distance(leaf_i, leaf_j)</code></pre><p>returns patristic distance between two leaves</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.patristic_distances" href="#SpectralInference.patristic_distances"><code>SpectralInference.patristic_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">patristic_distances(tree::Node)</code></pre><p>returns patristic distances between all pairs of leaves (leaves are in same order as <code>getleafnames</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.projectinLSV-Tuple{AbstractArray, SVD}" href="#SpectralInference.projectinLSV-Tuple{AbstractArray, SVD}"><code>SpectralInference.projectinLSV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectinLSV(data::AbstractArray{T}, usv::SVD{T}, [window])</code></pre><p>returns estimated left singular vectors (aka: LSV or Û) for new data based on already calculated SVD factorization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.projectinRSV-Tuple{AbstractArray, SVD}" href="#SpectralInference.projectinRSV-Tuple{AbstractArray, SVD}"><code>SpectralInference.projectinRSV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectinRSV(data::AbstractArray, usv::SVD, [window])</code></pre><p>returns estimated transposed right singular vectors (RSV or V̂ᵗ) for new data based on already calculated SVD factorization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.projectout-Tuple{SVD}" href="#SpectralInference.projectout-Tuple{SVD}"><code>SpectralInference.projectout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectout(usv::SVD, [window])</code></pre><p>recreates original matrix i.e. calculates <span>$UΣV&#39;$</span> or if window is included  creates a spectrally filtered version of the original matrix off of the provided components in <code>window</code>.</p><p>i.e., <code>usv.U[:, window] * diagm(usv.S[window]) * usv.Vt[window, :]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L163-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.readphylip-Tuple{AbstractString}" href="#SpectralInference.readphylip-Tuple{AbstractString}"><code>SpectralInference.readphylip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readphylip(fn::String)</code></pre><p>Read phylip alignment file, return dataframe of IDs and Sequences</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/parsephylip.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.scaledcumsum-Tuple{Any}" href="#SpectralInference.scaledcumsum-Tuple{Any}"><code>SpectralInference.scaledcumsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scaledcumsum(c; dims=1)</code></pre><p>cumsum divided by maximum cumulative value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/helpers.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.spectral_lineage_encoding" href="#SpectralInference.spectral_lineage_encoding"><code>SpectralInference.spectral_lineage_encoding</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spectral_lineage_encoding(tree::Node, orderedleafnames=getleafnames(tree); filterfun=x-&gt;true)</code></pre><p>returns vector of named tuples with the id <code>nodeid</code> of the node and <code>sle</code> a vector of booleans ordered by <code>orderedleafnames</code> where true indicates the leaf descends from the node and false indicates that it does not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/treefunctions.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.spectralcorrelations-Tuple{AbstractMatrix{&lt;:Number}, Any}" href="#SpectralInference.spectralcorrelations-Tuple{AbstractMatrix{&lt;:Number}, Any}"><code>SpectralInference.spectralcorrelations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_spcorr_mtx(vecs::AbstractMatrix{&lt;:Number}, window)
calc_spcorr_mtx(vecs::AbstractMatrix{&lt;:Number}, vals::AbstractVector{&lt;:Number}, window)</code></pre><p>Calculates pairwise spectral (spearman) correlations for a set of observations. </p><p>Args:</p><ul><li>vecs: set of left or right singular vectors with observations/features on rows and spectral components on columns</li><li>vals: vector of singular values</li><li>window: set of indices of <code>vecs</code> columns to compute correlations across</li></ul><p>Returns:</p><ul><li>correlation matrix where each pixel is the correlation between a pair of observations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L184-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.spectraldistances-Tuple{AbstractMatrix{&lt;:Number}}" href="#SpectralInference.spectraldistances-Tuple{AbstractMatrix{&lt;:Number}}"><code>SpectralInference.spectraldistances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spectraldistances(A::AbstractMatrix; [onrows=true, alpha=1.0, q=0.5])
spectraldistances(usv::SVD; [onrows=true, alpha=1.0, q=0.5])
spectraldistances(vecs::AbstactMatrix, vals::AbstractMatrix, intervals::AbstractVector{&lt;:UnitRange})</code></pre><p>computes the cumulative spectral residual distance for spectral phylogenetic inference</p><p><code>(∑_{p ∈ P} ||UₚΣₚ||₂)²</code></p><p>where <span>$P$</span> are the spectral partitions found with <code>getintervals</code>. </p><p>Args:</p><ul><li>A, usv: AbstractMatrix or SVD factorization (AbstractMatrix is passed to <code>svd()</code> before calculation)</li><li>onrows: if true will compute spectral distances on the left singular vectors (U matrix), if false will calculate on the right singular vectors or (V matrix)</li><li>alpha, q: are passed to <code>getintervals()</code> see its documentation</li></ul><p>Returns:</p><ul><li>distance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L57-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.spectraldistances_trace-Tuple{SVD}" href="#SpectralInference.spectraldistances_trace-Tuple{SVD}"><code>SpectralInference.spectraldistances_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spectraldistances_trace(usv::SVD; onrows=true, groups=nothing, alpha=1.0, q=0.5)
spectraldistances_trace(vecs, vals, groups)</code></pre><p>calculates spectral residual within each partition of spectrum and each pair of taxa</p><p>returns matrix where rows are spectral partitions and columns are taxa:taxa pairs ordered as the upper triangle in rowwise order, or lower triangle in colwise order.</p><p>Args:</p><ul><li>method: <code>spectraldistances_trace(vecs, vals, groups)</code><ul><li>vecs: either usv.U or usv.V matrix</li><li>vals: usv.S singular values vector</li><li>groups: usually calculated with <code>getintervals(usv.S; alpha=alpha, q=q)</code></li></ul></li><li>method: <code>spectraldistances_trace(usv::SVD; onrows=true, groups=nothing, alpha=1.0, q=0.5)</code>     <ul><li>usv: SVD object</li><li>onrows: true/false switch to calculate spectral distance on rows (U matrix) or columns (V matrix).</li><li>groups: if nothing groups are calculated with <code>getintervals(usv.S; alpha=alpha, q=q)</code>,    otherwise they assume a vector of index ranges <code>[1:1, 2:3, ...]</code> to group <code>usv.S</code> with. </li><li>alpha: passed to <code>getintervals</code></li><li>q: passed to <code>getintervals</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/core.jl#L100-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.squareform" href="#SpectralInference.squareform"><code>SpectralInference.squareform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">squareform(d::AbstractVector, fillvalue=zero(eltype(d)))
squareform(d::AbstractVector, fillvalue=zero(eltype(d)))</code></pre><p>If <code>d</code> is a vector, <code>squareform</code> checks if it of <code>n</code> choose 2 length for integer <code>n</code>, then fills the values of a symetric square matrix with the values of <code>d</code>.</p><p>If <code>d</code> is a matrix, <code>squareform</code> checks if it is square then fills the values of vector with the lower offdiagonal of matrix <code>d</code> in column order form. </p><p><code>fillvalue</code> is the initial value of the produced vector or matrix. Only really apparant in a produced matrix where it will be the values on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/helpers.jl#L59-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpectralInference.vmeasure_homogeneity_completeness-Tuple{Any, Any}" href="#SpectralInference.vmeasure_homogeneity_completeness-Tuple{Any, Any}"><code>SpectralInference.vmeasure_homogeneity_completeness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vmeasure_homogeneity_completeness(labels_true, labels_pred; β=1.)</code></pre><p>calculates and returns v-measure, homogeneity, completeness; similar to f-score, precision, and recall respectively</p><p>Args:</p><ul><li>β, weighting term for v-measure, if β is greater than 1 completeness</li></ul><p>is weighted more strongly in the calculation, if β is less than 1,  homogeneity is weighted more strongly</p><p>Citation:</p><ul><li>A. Rosenberg, J. Hirschberg, in Proceedings of the 2007 Joint Conference</li></ul><p>on Empirical Methods in Natural Language Processing and Computational Natural  Language Learning (EMNLP-CoNLL) (Association for Computational Linguistics,   Prague, Czech Republic, 2007; https://aclanthology.org/D07-1043), pp. 410–420.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SpectralInference.jl/blob/87f45400d1d5bf678b4f5fb4756b6b5d09f1178b/src/empiricalMI.jl#L136-L152">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 16 January 2024 17:24">Tuesday 16 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
